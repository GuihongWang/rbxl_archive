name: Archive WindowsPlayer Deployments

on:
  schedule:
    - cron: '0 0 * * *' # Run daily
  workflow_dispatch:

jobs:
  archive-windowsplayer:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        continue-on-error: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
        continue-on-error: false # Fail fast if Python setup fails

      - name: Set up WARP
        uses: fscarmen/warp-on-actions@v1.2
        with:
          stack: dual   # Optional. Support [ ipv4, ipv6, dual ]. Default is dual.


      - name: Install waybackpy
        run: |
          pip install waybackpy -U || { echo "Failed to install waybackpy"; exit 1; }
        continue-on-error: false # Fail if installation fails

      - name: Download and check DeployHistory
        id: check-deploy
        run: |
          binary_type=WindowsPlayer
          deploy_url=https://setup.rbxcdn.com/DeployHistory.txt
          type_filter=WindowsPlayer
          echo "Checking DeployHistory for $binary_type" | tee -a deploy_log_${binary_type}.txt
          
          # Try primary URL
          http_status=$(curl -s -w "%{http_code}" -o DeployHistory_${binary_type}.txt "$deploy_url" || echo "000")
          echo "HTTP status for $deploy_url: $http_status" | tee -a deploy_log_${binary_type}.txt
          
          if [ "$http_status" != "200" ]; then
            # Try fallback URL
            deploy_url="https://setup.rbxcdn.com/channel/common/DeployHistory.txt"
            http_status=$(curl -s -w "%{http_code}" -o DeployHistory_${binary_type}.txt "$deploy_url" || echo "000")
            echo "HTTP status for fallback $deploy_url: $http_status" | tee -a deploy_log_${binary_type}.txt
          fi

          if [ "$http_status" != "200" ] || [ ! -s DeployHistory_${binary_type}.txt ]; then
            echo "Warning: Failed to download valid DeployHistory for $binary_type (HTTP status: $http_status)" | tee -a deploy_log_${binary_type}.txt
            echo "updated=false" >> $GITHUB_OUTPUT
            echo "version=none" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Log last 10 lines for debugging
          echo "Last 10 lines of DeployHistory_${binary_type}.txt:" | tee -a deploy_log_${binary_type}.txt
          tail -n 10 DeployHistory_${binary_type}.txt >> deploy_log_${binary_type}.txt
          
          # Calculate hash
          hash=$(md5sum DeployHistory_${binary_type}.txt | awk '{print $1}' || echo "unknown")
          echo "$binary_type Hash: $hash" | tee -a deploy_log_${binary_type}.txt
          
          # Check for updates
          if [ -f "last_${binary_type}_hash.txt" ]; then
            last_hash=$(cat last_${binary_type}_hash.txt)
            if [ "$hash" != "$last_hash" ]; then
              echo "$binary_type DeployHistory updated!" | tee -a deploy_log_${binary_type}.txt
              echo "updated=true" >> $GITHUB_OUTPUT
            else
              echo "$binary_type DeployHistory unchanged" | tee -a deploy_log_${binary_type}.txt
              echo "updated=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "$binary_type DeployHistory first run" | tee -a deploy_log_${binary_type}.txt
            echo "updated=true" >> $GITHUB_OUTPUT
          fi
          echo "$hash" > last_${binary_type}_hash.txt
          
          # Extract and validate version
          version=$(grep "New $type_filter" DeployHistory_${binary_type}.txt | grep -o 'version-[0-9a-f]\{16\}' | tail -n 1 || echo "none")
          if ! [[ "$version" =~ ^version-[0-9a-f]{16}$ ]]; then
            echo "Invalid version format: $version" | tee -a deploy_log_${binary_type}.txt
            echo "version=none" >> $GITHUB_OUTPUT
          else
            echo "$binary_type Latest Version: $version" | tee -a deploy_log_${binary_type}.txt
            echo "version=$version" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Validate and archive package URLs
        if: steps.check-deploy.outputs.updated == 'true' && steps.check-deploy.outputs.version != 'none'
        run: |
          binary_type=WindowsPlayer
          version=${{ steps.check-deploy.outputs.version }}
          blob_dir=/
          echo "" > valid_urls_${binary_type}.txt
          echo "" > archive_log_${binary_type}.txt
          echo "" > archive_status_${binary_type}.txt
          
          # Validate manifest and get package list dynamically
          manifest_url="https://setup.rbxcdn.com${blob_dir}${version}-rbxPkgManifest.txt"
          status=$(curl -s -I -o /dev/null -w "%{http_code}" "$manifest_url" || echo "000")
          echo "Checking manifest: $manifest_url (status: $status)" | tee -a archive_log_${binary_type}.txt
          if [ "$status" == "200" ]; then
            echo "Manifest found: $manifest_url" | tee -a archive_log_${binary_type}.txt
            echo "$manifest_url" >> valid_urls_${binary_type}.txt
            # Download manifest to extract package list
            curl -s -o rbxPkgManifest.txt "$manifest_url"
            # Log manifest content for debugging
            echo "Content of rbxPkgManifest.txt:" | tee -a archive_log_${binary_type}.txt
            cat rbxPkgManifest.txt >> archive_log_${binary_type}.txt
            # Extract .zip filenames (every 4th line starting from line 2, assuming format: filename, hash, size1, size2)
            packages=$(awk 'NR % 4 == 2 && /\.zip$/ {print $1}' rbxPkgManifest.txt | sort -u)
            total_packages=$(echo "$packages" | wc -l)
            echo "Extracted $total_packages .zip packages: $packages" | tee -a archive_log_${binary_type}.txt
          else
            packages=""
            total_packages=0
            echo "No valid manifest found, skipping package validation" | tee -a archive_log_${binary_type}.txt
          fi
          
          # Validate package files
          package_count=0
          for pkg in $packages; do
            pkg_url="https://setup.rbxcdn.com${blob_dir}${version}-${pkg}"
            pkg_status=$(curl -s -I -o /dev/null -w "%{http_code}" "$pkg_url" || echo "000")
            echo "Checking package ($((++package_count))/$((total_packages))): $pkg_url (status: $pkg_status)" | tee -a archive_log_${binary_type}.txt
            if [ "$pkg_status" == "200" ]; then
              echo "Valid package: $pkg_url" | tee -a archive_log_${binary_type}.txt
              echo "$pkg_url" >> valid_urls_${binary_type}.txt
            fi
          done

          # Archive URLs with retries and parallel processing
          if [ -s valid_urls_${binary_type}.txt ]; then
            grep -v '^$' valid_urls_${binary_type}.txt > valid_urls_${binary_type}_filtered.txt
            mv valid_urls_${binary_type}_filtered.txt valid_urls_${binary_type}.txt
            total_urls=$(wc -l < valid_urls_${binary_type}.txt)
            url_count=0
            user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
            
            # Process URLs in parallel, limiting to 4 concurrent processes
            while IFS= read -r url; do
              [ -z "$url" ] && continue
              url_count=$((url_count + 1))
              echo "Archiving URL $url_count/$total_urls: $url" | tee -a archive_log_${binary_type}.txt
              # Run archiving in background
              {
                for attempt in {1..3}; do
                  waybackpy --url "$url" --user-agent "$user_agent" --save >> archive_log_${binary_type}.txt 2>&1
                  if [ $? -eq 0 ]; then
                    echo "Successfully archived URL $url_count/$total_urls: $url (attempt $attempt)" | tee -a archive_log_${binary_type}.txt
                    echo "$url,SUCCESS,$attempt" >> archive_status_${binary_type}.txt
                    break
                  else
                    echo "Failed to archive URL $url_count/$total_urls: $url (attempt $attempt)" | tee -a archive_log_${binary_type}.txt
                    if [ $attempt -lt 3 ]; then
                      sleep $((30 * 2 ** ($attempt - 1)))
                      echo "Retrying in $((30 * 2 ** ($attempt - 1))) seconds..." | tee -a archive_log_${binary_type}.txt
                    fi
                  fi
                done
                if [ $? -ne 0 ]; then
                  echo "Failed to archive URL $url_count/$total_urls after 3 attempts: $url" | tee -a archive_log_${binary_type}.txt
                  echo "$url,FAILED,3" >> archive_status_${binary_type}.txt
                fi
              } &
              # Limit to 4 concurrent processes
              if [ $((url_count % 4)) -eq 0 ]; then
                wait
              fi
            done < valid_urls_${binary_type}.txt
            wait # Wait for all background processes to complete
          else
            echo "No valid URLs to archive for $binary_type" | tee -a archive_log_${binary_type}.txt
          fi
        continue-on-error: true

      - name: Download valid packages
        if: steps.check-deploy.outputs.updated == 'true' && steps.check-deploy.outputs.version != 'none'
        run: |
          binary_type=WindowsPlayer
          mkdir -p downloads/${binary_type}
          if [ -s valid_urls_${binary_type}.txt ]; then
            total_urls=$(wc -l < valid_urls_${binary_type}.txt)
            echo "Starting parallel download of $total_urls packages" | tee -a archive_log_${binary_type}.txt
            # Parallel download with xargs, limiting to 4 concurrent processes
            cat valid_urls_${binary_type}.txt | xargs -I {} -P 4 bash -c '
              url="{}"
              [ -z "$url" ] && { echo "Skipping empty URL for download" | tee -a archive_log_${binary_type}.txt; exit 0; }
              filename=$(basename "$url")
              echo "Downloading package: $url" | tee -a archive_log_${binary_type}.txt
              curl -s -L -o "downloads/${binary_type}/${filename}" "$url" || echo "Failed to download $url" | tee -a archive_log_${binary_type}.txt
              if [ $? -eq 0 ]; then
                echo "Successfully downloaded package: $url to downloads/${binary_type}/${filename}" | tee -a archive_log_${binary_type}.txt
              fi
            '
            # Validate checksums if available in manifest
            if [ -f rbxPkgManifest.txt ]; then
              awk 'NR % 4 == 2 && /\.zip$/ {print $1, $(NR+1)}' rbxPkgManifest.txt | while read -r filename expected_hash; do
                if [ -f "downloads/${binary_type}/${filename}" ]; then
                  actual_hash=$(md5sum "downloads/${binary_type}/${filename}" | awk '{print $1}')
                  if [ "$expected_hash" = "$actual_hash" ]; then
                    echo "Checksum verified for $filename" | tee -a archive_log_${binary_type}.txt
                  else
                    echo "Checksum mismatch for $filename: expected $expected_hash, got $actual_hash" | tee -a archive_log_${binary_type}.txt
                  fi
                fi
              done
            fi
          else
            echo "No valid URLs to download for $binary_type" | tee -a archive_log_${binary_type}.txt
          fi
        continue-on-error: true

      - name: Summarize results
        if: always()
        run: |
          binary_type=WindowsPlayer
          valid_urls_count=$(wc -l < valid_urls_${binary_type}.txt 2>/dev/null || echo 0)
          archived_success_count=$(grep -c "SUCCESS" archive_status_${binary_type}.txt 2>/dev/null || echo 0)
          archived_failed_count=$(grep -c "FAILED" archive_status_${binary_type}.txt 2>/dev/null || echo 0)
          downloaded_count=$(ls -1 downloads/${binary_type} 2>/dev/null | wc -l || echo 0)
          echo "Summary: $valid_urls_count URLs validated, $archived_success_count URLs archived successfully, $archived_failed_count URLs failed to archive, $downloaded_count packages downloaded" | tee -a archive_log_${binary_type}.txt
          # Save metrics for historical tracking
          echo "$(date +%F),$valid_urls_count,$archived_success_count,$archived_failed_count,$downloaded_count" >> metrics_${binary_type}.csv
        continue-on-error: true

      - name: Upload logs and valid URLs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: logs-and-urls-WindowsPlayer
          path: |
            deploy_log_WindowsPlayer.txt
            valid_urls_WindowsPlayer.txt
            archive_log_WindowsPlayer.txt
            archive_status_${binary_type}.txt
            metrics_${binary_type}.csv
            rbxPkgManifest.txt
        continue-on-error: true

      - name: Upload downloaded packages
        if: steps.check-deploy.outputs.updated == 'true' && steps.check-deploy.outputs.version != 'none'
        uses: actions/upload-artifact@v4
        with:
          name: packages-WindowsPlayer
          path: downloads/WindowsPlayer/*
        continue-on-error: true
