name: Archive WindowsPlayer Deployments

on:
  schedule:
    - cron: '0 0 * * *' # Run daily
  workflow_dispatch:

jobs:
  archive-windowsplayer:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        continue-on-error: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
        continue-on-error: true

      - name: Set up WARP
        uses: fscarmen/warp-on-actions@v1.3
        with:
         stack: dual        # Optional. Support [ ipv4, ipv6, dual ]. Default is dual.
         mode: wireguard    # Optional. Support [ wireguard, client ]. Default is wireguard.

      - name: Install waybackpy
        run: |
          pip install waybackpy -U || echo "Failed to install waybackpy, continuing..."
        continue-on-error: true

      - name: Download and check DeployHistory
        id: check-deploy
        run: |
          binary_type=WindowsPlayer
          deploy_url=https://setup.rbxcdn.com/DeployHistory.txt
          type_filter=WindowsPlayer
          echo "Checking DeployHistory for $binary_type" | tee -a deploy_log_${binary_type}.txt
          
          # Try primary URL
          http_status=$(curl -s -w "%{http_code}" -o DeployHistory_${binary_type}.txt "$deploy_url" || echo "000")
          echo "HTTP status for $deploy_url: $http_status" | tee -a deploy_log_${binary_type}.txt
          
          if [ "$http_status" != "200" ]; then
            # Try fallback URL
            deploy_url="https://setup.rbxcdn.com/channel/common/DeployHistory.txt"
            http_status=$(curl -s -w "%{http_code}" -o DeployHistory_${binary_type}.txt "$deploy_url" || echo "000")
            echo "HTTP status for fallback $deploy_url: $http_status" | tee -a deploy_log_${binary_type}.txt
          fi

          if [ "$http_status" != "200" ] || [ ! -s DeployHistory_${binary_type}.txt ]; then
            echo "Warning: Failed to download valid DeployHistory for $binary_type (HTTP status: $http_status)" | tee -a deploy_log_${binary_type}.txt
            echo "updated=false" >> $GITHUB_OUTPUT
            echo "version=none" >> $GITHUB_OUTPUT
          else
            # Log last 10 lines for debugging
            echo "Last 10 lines of DeployHistory_${binary_type}.txt:" | tee -a deploy_log_${binary_type}.txt
            tail -n 10 DeployHistory_${binary_type}.txt >> deploy_log_${binary_type}.txt
            
            # Calculate hash
            hash=$(md5sum DeployHistory_${binary_type}.txt | awk '{print $1}' || echo "unknown")
            echo "$binary_type Hash: $hash" | tee -a deploy_log_${binary_type}.txt
            
            # Check for updates
            if [ -f "last_${binary_type}_hash.txt" ]; then
              last_hash=$(cat last_${binary_type}_hash.txt)
              if [ "$hash" != "$last_hash" ]; then
                echo "$binary_type DeployHistory updated!" | tee -a deploy_log_${binary_type}.txt
                echo "updated=true" >> $GITHUB_OUTPUT
              else
                echo "$binary_type DeployHistory unchanged" | tee -a deploy_log_${binary_type}.txt
                echo "updated=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "$binary_type DeployHistory first run" | tee -a deploy_log_${binary_type}.txt
              echo "updated=true" >> $GITHUB_OUTPUT
            fi
            echo "$hash" > last_${binary_type}_hash.txt
            
            # Extract version
            version=$(grep "New $type_filter" DeployHistory_${binary_type}.txt | grep -o 'version-[0-9a-f]\{16\}' | tail -n 1 || echo "none")
            echo "$binary_type Latest Version: $version" | tee -a deploy_log_${binary_type}.txt
            echo "version=$version" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Validate and archive package URLs
        if: steps.check-deploy.outputs.updated == 'true' && steps.check-deploy.outputs.version != 'none'
        run: |
          binary_type=WindowsPlayer
          version=${{ steps.check-deploy.outputs.version }}
          blob_dir=/
          echo "" > valid_urls_${binary_type}.txt
          echo "" > archive_log_${binary_type}.txt
          
          # Validate packages
          manifest_url="https://setup.rbxcdn.com${blob_dir}${version}-rbxPkgManifest.txt"
          total_packages=21
          package_count=0
          
          # Check manifest
          status=$(curl -s -I -o /dev/null -w "%{http_code}" "$manifest_url" || echo "000")
          echo "Checking manifest ($((++package_count))/$((total_packages + 1))): $manifest_url (status: $status)" | tee -a archive_log_${binary_type}.txt
          if [ "$status" == "200" ]; then
            echo "Manifest found: $manifest_url" | tee -a archive_log_${binary_type}.txt
            echo "$manifest_url" >> valid_urls_${binary_type}.txt
          fi
          
          # Validate package files
          for pkg in RobloxApp.zip redist.zip shaders.zip ssl.zip WebView2.zip WebView2RuntimeInstaller.zip content-avatar.zip content-configs.zip content-fonts.zip content-sky.zip content-sounds.zip content-textures2.zip content-models.zip content-platform-fonts.zip content-platform-dictionaries.zip content-terrain.zip content-textures3.zip extracontent-luapackages.zip extracontent-translations.zip extracontent-models.zip extracontent-textures.zip extracontent-places.zip; do
            pkg_url="https://setup.rbxcdn.com${blob_dir}${version}-${pkg}"
            pkg_status=$(curl -s -I -o /dev/null -w "%{http_code}" "$pkg_url" || echo "000")
            echo "Checking package ($((++package_count))/$((total_packages + 1))): $pkg_url (status: $pkg_status)" | tee -a archive_log_${binary_type}.txt
            if [ "$pkg_status" == "200" ]; then
              echo "Valid package: $pkg_url" | tee -a archive_log_${binary_type}.txt
              echo "$pkg_url" >> valid_urls_${binary_type}.txt
            fi
          done

          # Archive URLs with retries and parallel processing
          if [ -s valid_urls_${binary_type}.txt ]; then
            grep -v '^$' valid_urls_${binary_type}.txt > valid_urls_${binary_type}_filtered.txt
            mv valid_urls_${binary_type}_filtered.txt valid_urls_${binary_type}.txt
            total_urls=$(wc -l < valid_urls_${binary_type}.txt)
            url_count=0
            user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
            
            # Process URLs in parallel with xargs, limiting to 6 concurrent processes
            cat valid_urls_${binary_type}.txt | xargs -n 1 -P 6 -I {} bash -c '
              url="{}"
              [ -z "$url" ] && { echo "Skipping empty URL" | tee -a archive_log_${binary_type}.txt; exit 0; }
              url_count=$((url_count + 1))
              echo "Archiving URL $url_count/$total_urls: $url" | tee -a archive_log_${binary_type}.txt
              
              # Attempt archiving with up to 3 retries
              for attempt in {1..3}; do
                python -c "import waybackpy; wb = waybackpy.Url(\"$url\", \"$user_agent\"); archive = wb.save(); print(f\"Archived URL: {archive}\")" >> archive_log_${binary_type}.txt 2>&1
                if [ $? -eq 0 ]; then
                  echo "Successfully archived URL $url_count/$total_urls: $url (attempt $attempt)" | tee -a archive_log_${binary_type}.txt
                  break
                else
                  echo "Failed to archive URL $url_count/$total_urls: $url (attempt $attempt)" | tee -a archive_log_${binary_type}.txt
                  if [ $attempt -lt 3 ]; then
                    echo "Retrying in 300 seconds..." | tee -a archive_log_${binary_type}.txt
                    sleep 300
                  fi
                fi
              done
              if [ $? -ne 0 ]; then
                echo "Failed to archive URL $url_count/$total_urls after 3 attempts: $url" | tee -a archive_log_${binary_type}.txt
              fi
            ' -- url_count=$url_count total_urls=$total_urls binary_type=$binary_type user_agent="$user_agent"
          else
            echo "No valid URLs to archive for $binary_type" | tee -a archive_log_${binary_type}.txt
          fi
        continue-on-error: true

      - name: Download valid packages
        if: steps.check-deploy.outputs.updated == 'true' && steps.check-deploy.outputs.version != 'none'
        run: |
          binary_type=WindowsPlayer
          mkdir -p downloads/${binary_type}
          if [ -s valid_urls_${binary_type}.txt ]; then
            total_urls=$(wc -l < valid_urls_${binary_type}.txt)
            url_count=0
            while read -r url; do
              [ -z "$url" ] && { echo "Skipping empty URL for download" | tee -a archive_log_${binary_type}.txt; continue; }
              url_count=$((url_count + 1))
              filename=$(basename "$url")
              echo "Downloading package ($url_count/$total_urls): $url" | tee -a archive_log_${binary_type}.txt
              curl -s -L -o "downloads/${binary_type}/${filename}" "$url" || echo "Failed to download $url, continuing..."
              if [ $? -eq 0 ]; then
                echo "Successfully downloaded package ($url_count/$total_urls): $url to downloads/${binary_type}/${filename}" | tee -a archive_log_${binary_type}.txt
              fi
            done < valid_urls_${binary_type}.txt
          else
            echo "No valid URLs to download for $binary_type" | tee -a archive_log_${binary_type}.txt
          fi
        continue-on-error: true

      - name: Upload logs and valid URLs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: logs-and-urls-WindowsPlayer
          path: |
            deploy_log_WindowsPlayer.txt
            valid_urls_WindowsPlayer.txt
            archive_log_WindowsPlayer.txt
        continue-on-error: true

      - name: Upload downloaded packages
        if: steps.check-deploy.outputs.updated == 'true' && steps.check-deploy.outputs.version != 'none'
        uses: actions/upload-artifact@v4
        with:
          name: packages-WindowsPlayer
          path: downloads/WindowsPlayer/*
        continue-on-error: true
